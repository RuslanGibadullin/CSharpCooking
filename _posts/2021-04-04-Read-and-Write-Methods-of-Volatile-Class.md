---
layout: post
title: "Применение методов Read, Write класса Volatile"
date: 2021-04-04
---
В многопроцессорной системе операция volatile-запись гарантирует, что значение, записываемое в область памяти, сразу же становится видимым для всех процессоров. Операция volatile-чтение получает самое последнее значение, записанное в область памяти любым процессором. Для этих операций может потребоваться очистка кэша процессора, что может повлиять на производительность.

Например, запустив релиз нижеуказанного кода, можно увидеть, что программа не завершается за приемлемый временный промежуток.

```csharp
class Program
{
  static bool finish = false;
  static void Main()
  {
    new Thread(ThreadProc).Start();
    int x = 0;
    while (!finish)
      x++;
  }
  static void ThreadProc()
  {
    Thread.Sleep(1000);
    finish = true;
  }
}
```
Почему так? Дело в том, что компилятор, среда CLR и процессор имеют право изменять порядок следования инструкций и кешировать переменные в регистрах центрального процессора в целях улучшения производительности – до тех пор, пока такие оптимизации не изменяют поведение однопоточной программы (или многопоточной программы, в которой используются блокировки). В нашем случае оптимизатор определил, что переменная `finish` с точки зрения основного потока не меняется, и указал ограничиться чтением значения из регистра. А так как в условиях многопоточного программирования невозможно прогнозировать число операций чтения устаревших данных, то получаем непредсказуемый результат. Решением является применение volatile-операций.
```csharp
class Program
{
  static bool finish = false;
  static void Main()
  {
    new Thread(ThreadProc).Start();
    int x = 0;
    while (!Volatile.Read(ref finish))
      x++;
  }
  static void ThreadProc()
  {
    Thread.Sleep(1000);
    Volatile.Write(ref finish, true);
  }
}
```