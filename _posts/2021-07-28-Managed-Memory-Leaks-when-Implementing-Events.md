---
layout: post
title: "Утечки управляемой памяти при реализации событий"
date: 2021-07-28
---
В посте показано, каким образом события могут вызывать утечки управляемой памяти. Предлагаются два решения, чтобы избежать подобных утечек. Первое решение связано с реализацией метода `Dispose` для отмены подписки, во втором решении демонстрируется применение слабых ссылок.

## Проблематика[^1]

В неуправляемых языках вроде C++ вы должны не забывать об освобождении памяти вручную, когда объект больше не требуется; в противном случае возникнет утечка памяти. В мире управляемых языков такая ошибка невозможна, поскольку в среде CLR существует система автоматической сборки мусора.

Несмотря на это, крупные и сложные приложения .NET могут демонстрировать аналогичный синдром в легкой форме с тем же самым конечным результатом: с течением времени жизни приложение потребляет все больше и больше памяти до тех пор, пока его не придется перезапустить. Хорошая новость в том, что утечки управляемой памяти обычно легче диагностировать и предотвращать.

Утечки управляемой памяти вызваны неиспользуемыми объектами, которые остаются активными по причине существования неиспользуемых или забытых ссылок на них. Распространенным кандидатом являются обработчики событий – они удерживают ссылку на целевой объект (если только он не является статическим методом).

Например, взгляните на следующие классы:

```csharp
class Host
{
  public event EventHandler Click;
}
class Client
{
  Host _host;
  public Client(Host host)
  {
    _host = host;
    _host.Click += HostClicked;
  }
  void HostClicked(object sender, EventArgs e) { ... }
}
```

Приведенный ниже тестовый класс содержит метод, который создает 1000 экземпляров класса `Client`:

```csharp
class Test
{
	static Host _host = new Host();
	public static void CreateClients()
	{
		Client[] clients = Enumerable.Range(0, 1000)
		.Select(i => new Client(_host))
		.ToArray();
		// Делать что-нибудь с экземплярами класса Client...
	}
}
```

Может показаться, что после того, как метод `CreateClients` завершит выполнение, тысяча объектов `Client` станут пригодными для сборки мусора. К сожалению, на каждый объект `Client` имеется еще одна ссылка: объект `_host`, событие `Click` которого теперь ссылается на каждый экземпляр `Client`.

## Первое решение[^1]

Один из способов решения проблемы – обеспечить, чтобы класс `Client` реализовывал интерфейс `IDisposable`, и в методе `Dispose` отсоединиться от обработчика событий:
```csharp
public void Dispose() { _host.Click -= HostClicked; }
```
Тогда потребители класса `Client` освободят его экземпляры после завершения работы с ними:
```csharp
Array.ForEach (clients, с => с.Dispose ());
```

## Второе решение[^1]

Слабые ссылки предлагают еще одно решение. Предположим, что есть делегат, который удерживает только слабые ссылки на свои целевые объекты. Такой делегат не будет сохранять свои целевые объекты в активном состоянии – если только не существуют независимые ссылки на них. Конечно, при этом нельзя предотвратить ситуацию, когда запущенный делегат сталкивается с висячей ссылкой на целевой объект – в период времени между моментом, когда целевой объект пригоден для сборки мусора, и моментом, когда сборщик мусора подхватит его. Чтобы такое решение было эффективным, код должен быть надежным в указанном сценарии. С учетом этого случая класс слабого делегата может быть реализован так, как показано ниже:

```csharp
public class WeakDelegate<TDelegate> where TDelegate : class
{
  class MethodTarget
  {
    public readonly WeakReference Reference;
    public readonly Methodlnfo Method;
    public MethodTarget(Delegate d)
    {
      // d.Target будет null для целей в виде статических методов:
      if (d.Target != null) Reference = new WeakReference(d.Target);
      Method = d.Method;
    }
  }
  List<MethodTarget> _targets = new List<MethodTarget>();
  public WeakDelegate()
  {
    if (!typeof(TDelegate).IsSubclassOf(typeof(Delegate)))
      throw new InvalidOperationException
      ("TDelegate must be a delegate type");
      // TDelegate должен быть типом делегата
  }
  public void Combine(TDelegate target)
  {
    if (target == null) return;
    foreach (Delegate d in (target as Delegate).GetInvocationList())
      _targets.Add(new MethodTarget(d));
  }
  public void Remove(TDelegate target)
  {
    if (target == null) return;
    foreach (Delegate d in (target as Delegate).GetInvocationList())
    {
      MethodTarget mt = _targets.Find(w =>
       Equals(d.Target, w.Reference?.Target) &&
       Equals(d.Method.MethodHandle, w.Method.MethodHandle));
      if (mt != null) _targets.Remove(mt);
    }
  }
  public TDelegate Target
  {
    get
    {
      Delegate combinedTarget = null;
      foreach (MethodTarget mt in _targets.ToArray())
      {
        WeakReference wr = mt.Reference;
        // Статический целевой объект или активный целевой объект экземпляра
        if (wr == null || wr.Target != null)
        {
          var newDelegate = Delegate.CreateDelegate(
          typeof(TDelegate), wr?.Target, mt.Method);
          combinedTarget = Delegate.Combine(combinedTarget, newDelegate);
        }
        else
          _targets.Remove(mt);
      }
      return combinedTarget as TDelegate;
    }
    set
    {
      _targets.Clear();
      Combine(value);
    }
  }
}
```

В приведенном коде демонстрируется несколько интересных моментов, связанных с C# и CLR. Для начала обратите внимание на проверку `TDelegate` на принадлежность к типу делегата в конструкторе. Это объясняется особенностью C# – следующее ограничение типа является недопустимым, т.к. C# считает `System.Delegate` специальным типом, для которого ограничения не поддерживаются:

```csharp
... where TDelegate : Delegate 
// Компилятор не разрешает поступать
// подобным образом
```

Взамен мы должны выбрать ограничение класса и предусмотреть в конструкторе проверку во время выполнения.

В методах `Combine` и `Remove` мы осуществляем ссылочное преобразование `target` в `Delegate` с помощью операции `as`, а не более привычной операции приведения. Причина в том, что C# запрещает использовать операцию приведения с таким параметром типа, поскольку существует потенциальная неоднозначность между специальным, преобразованием и ссылочным преобразованием.

Затем мы вызываем метод `GetInvocationList`, т.к. эти методы могут быть вызваны групповыми делегатами, т.е. делегатами с более чем одним методом для вызова.

В свойстве `Target` мы строим групповой делегат, комбинирующий все делегаты, на которые имеются слабые ссылки с активными целевыми объектами, удаляя оставшиеся (висячие) ссылки из списка `_targets` во избежание его разрастания до бесконечности. (Мы могли бы усовершенствовать наш класс, делая то же самое в методе `Combine`; еще одним улучшением было бы добавление блокировок для обеспечения безопасности в отношении потоков.) Мы также разрешаем иметь делегаты вообще без слабой ссылки; они представляют делегаты, целевой метод которых является статическим.

В следующем коде показано, как использовать готовый делегат при реализации события.

```csharp
public class Foo
{
  WeakDelegate<EventHandler> _click = 
    new WeakDelegate<EventHandler>();
  public event EventHandler Click
  {
    add { _click.Combine(value); }
    remove { _click.Remove(value); }
  }
  protected virtual void OnClick(EventArgs e)
  => _click.Target?.Invoke(this, e);
}
```

[^1]: Албахари Д. C# 7.0. Справочник. Полное описание языка / Албахари Д., Албахари Б. // Пер. с англ. – Москва: Альфа-Книга. – 2018. (Глава 12. Освобождение и сборка мусора.)