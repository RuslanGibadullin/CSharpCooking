---
layout: post
title: "Назначение методов Read, Write класса Volatile"
date: 2021-04-04
---
В многопроцессорной системе операция _volatile-запись_ гарантирует, что значение, записываемое в область памяти, сразу же становится видимым для всех процессоров. Операция _volatile-чтение_ получает самое последнее значение, записанное в область памяти любым процессором. Для этих операций может потребоваться очистка кэша процессора, что может повлиять на производительность.

Например, запустив релиз нижеуказанного кода, можно увидеть, что программа не завершается за приемлемый временный промежуток.

```c#
class Program
{
  static bool finish = false;
  static void Main()
  {
    new Thread(ThreadProc).Start();
    int x = 0;
    while (!finish)
      x++;
  }
  static void ThreadProc()
  {
    Thread.Sleep(1000);
    finish = true;
  }
}
```
Почему так? Дело в том, что компилятор, среда CLR и процессор имеют право изменять порядок следования инструкций и кешировать переменные в регистрах центрального процессора в целях улучшения производительности – до тех пор, пока такие оптимизации не изменяют поведение однопоточной программы (или многопоточной программы, в которой используются блокировки). В нашем случае оптимизатор определил, что переменная `finish` с точки зрения основного потока не меняется, и указал ограничиться чтением значения из регистра. А так как в условиях многопоточного программирования невозможно прогнозировать число операций чтения устаревших данных, то получаем непредсказуемый результат. Решением является применение _volatile-операций_.
```c#
class Program
{
  static bool finish = false;
  static void Main()
  {
    new Thread(ThreadProc).Start();
    int x = 0;
    while (!Volatile.Read(ref finish))
      x++;
  }
  static void ThreadProc()
  {
    Thread.Sleep(1000);
    Volatile.Write(ref finish, true);
  }
}
```
[^1]: Volatile Класс [Электронный ресурс] // © Microsoft 2021. URL: <https://docs.microsoft.com/ru-ru/dotnet/api/system.threading.volatile?view=net-5.0> (дата обращения: 31.03.2021).